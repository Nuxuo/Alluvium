#pragma kernel CSMain

#include "FastNoise.hlsl"

// Input
StructuredBuffer<float> heightMap;

// Block type configurations (dynamic array)
struct BlockTypeConfig
{
    int blockType;
    int heightMode; // 0 = Normalized, 1 = VoxelLayers
    float minHeight;
    float maxHeight;
    float heightBlendAmount;
    int minVoxelLayer;
    int maxVoxelLayer;
    int voxelLayerBlend;
    float minSlope;
    float maxSlope;
    float slopeBlendAmount;
    int priority;
    float strength;
    int useNoiseVariation;
    float noiseInfluence;
    float padding;
};

StructuredBuffer<BlockTypeConfig> blockConfigs;

// Output
RWStructuredBuffer<uint> blockData;

// Parameters
int mapSize;
int mapSizeWithBorder;
int borderSize;
float elevationScale;
float cellSize;
int numBlockTypes;

// Voxel parameters
float voxelSize;
int maxVoxelLayers;

// Noise settings for blending
int seed;
float blendNoiseScale;

// Get height at position with bounds checking
float GetHeight(int x, int z)
{
    x = clamp(x, 0, mapSize - 1);
    z = clamp(z, 0, mapSize - 1);
    
    int borderedIndex = (z + borderSize) * mapSizeWithBorder + (x + borderSize);
    return heightMap[borderedIndex] * elevationScale;
}

// Calculate slope at a position (0 = flat, higher = steeper)
float CalculateSlope(int x, int z)
{
    float heightC = GetHeight(x, z);
    float heightL = GetHeight(x - 1, z);
    float heightR = GetHeight(x + 1, z);
    float heightD = GetHeight(x, z - 1);
    float heightU = GetHeight(x, z + 1);
    
    float dx = (heightR - heightL) / (2.0 * cellSize);
    float dz = (heightU - heightD) / (2.0 * cellSize);
    
    float slopeMagnitude = sqrt(dx * dx + dz * dz);
    return slopeMagnitude;
}

// Generate blend noise for smooth transitions
float GetBlendNoise(int x, int z)
{
    fnl_state state = fnlCreateState(seed);
    state.noise_type = FNL_NOISE_OPENSIMPLEX2;
    state.frequency = blendNoiseScale;
    
    return fnlGetNoise2D(state, x, z); // Range: -1 to 1
}

// Smooth step function for blending
float SmoothStep(float edge0, float edge1, float x)
{
    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);
}

// Calculate voxel layer from normalized height
int CalculateVoxelLayer(float normalizedHeight)
{
    float worldHeight = normalizedHeight * elevationScale;
    return max(1, (int) round(worldHeight / voxelSize));
}

// Calculate fitness score for a block type at given height and slope
float CalculateBlockFitness(BlockTypeConfig config, float normalizedHeight, float slope, float noise)
{
    float fitness = 0.0;
    
    // Apply noise variation to values if enabled
    float heightNoise = (config.useNoiseVariation != 0) ? noise * config.noiseInfluence * config.heightBlendAmount : 0.0;
    float slopeNoise = (config.useNoiseVariation != 0) ? noise * config.noiseInfluence * config.slopeBlendAmount * 0.5 : 0.0;
    
    float adjustedSlope = slope + slopeNoise;
    
    // === HEIGHT FITNESS (mode-dependent) ===
    float heightFitness = 0.0;
    
    if (config.heightMode == 0) // Normalized mode
    {
        float adjustedHeight = normalizedHeight + heightNoise;
        
        // Full fitness in the middle of the range
        float heightCenter = (config.minHeight + config.maxHeight) * 0.5;
        float heightRange = config.maxHeight - config.minHeight;
        
        // Calculate distance from center (0 = center, 1 = edge)
        float distFromCenter = abs(adjustedHeight - heightCenter) / (heightRange * 0.5);
        
        // Apply blend at edges
        if (adjustedHeight < config.minHeight + config.heightBlendAmount)
        {
            heightFitness = SmoothStep(config.minHeight, config.minHeight + config.heightBlendAmount, adjustedHeight);
        }
        else if (adjustedHeight > config.maxHeight - config.heightBlendAmount)
        {
            heightFitness = 1.0 - SmoothStep(config.maxHeight - config.heightBlendAmount, config.maxHeight, adjustedHeight);
        }
        else
        {
            heightFitness = 1.0; // Full fitness in middle
        }
    }
    else
    {
        // Outside range - check if we're in blend zone
        float adjustedHeight = normalizedHeight + heightNoise;
        
        if (adjustedHeight < config.minHeight)
        {
            float distFromMin = config.minHeight - adjustedHeight;
            if (distFromMin < config.heightBlendAmount)
            {
                heightFitness = SmoothStep(config.minHeight - config.heightBlendAmount, config.minHeight, adjustedHeight);
            }
        }
        else if (adjustedHeight > config.maxHeight)
        {
            float distFromMax = adjustedHeight - config.maxHeight;
            if (distFromMax < config.heightBlendAmount)
            {
                heightFitness = 1.0 - SmoothStep(config.maxHeight, config.maxHeight + config.heightBlendAmount, adjustedHeight);
            }
        }
    }
    
    // === SLOPE FITNESS ===
    float slopeFitness = 0.0;
    
    // Check if within slope range
    if (adjustedSlope >= config.minSlope && adjustedSlope <= config.maxSlope)
    {
        // Apply blend at edges
        if (adjustedSlope < config.minSlope + config.slopeBlendAmount)
        {
            slopeFitness = SmoothStep(config.minSlope, config.minSlope + config.slopeBlendAmount, adjustedSlope);
        }
        else if (adjustedSlope > config.maxSlope - config.slopeBlendAmount)
        {
            slopeFitness = 1.0 - SmoothStep(config.maxSlope - config.slopeBlendAmount, config.maxSlope, adjustedSlope);
        }
        else
        {
            slopeFitness = 1.0;
        }
    }
    else
    {
        // Outside range - check blend zones
        if (adjustedSlope < config.minSlope)
        {
            float distFromMin = config.minSlope - adjustedSlope;
            if (distFromMin < config.slopeBlendAmount)
            {
                slopeFitness = SmoothStep(config.minSlope - config.slopeBlendAmount, config.minSlope, adjustedSlope);
            }
        }
        else if (adjustedSlope > config.maxSlope)
        {
            float distFromMax = adjustedSlope - config.maxSlope;
            if (distFromMax < config.slopeBlendAmount)
            {
                slopeFitness = 1.0 - SmoothStep(config.maxSlope, config.maxSlope + config.slopeBlendAmount, adjustedSlope);
            }
        }
    }
    
    // Combine height and slope fitness (both must be satisfied)
    fitness = heightFitness * slopeFitness;
    
    // Apply strength multiplier
    fitness *= config.strength;
    
    return fitness;
}

// Determine best block type based on all configurations
int DetermineBlockType(float normalizedHeight, float slope, float noise)
{
    int bestBlockType = 0; // Default to first block type
    float bestScore = -1.0;
    int bestPriority = -1;
    
    // Evaluate each block type configuration
    for (int i = 0; i < numBlockTypes; i++)
    {
        BlockTypeConfig config = blockConfigs[i];
        
        float fitness = CalculateBlockFitness(config, normalizedHeight, slope, noise);
        
        // Determine if this is the best choice so far
        // Priority ties: higher priority wins
        // Priority equal: higher fitness wins
        bool isBetter = false;
        
        if (config.priority > bestPriority)
        {
            isBetter = true;
        }
        else if (config.priority == bestPriority && fitness > bestScore)
        {
            isBetter = true;
        }
        
        if (isBetter && fitness > 0.01) // Minimum threshold
        {
            bestBlockType = config.blockType;
            bestScore = fitness;
            bestPriority = config.priority;
        }
    }
    
    return bestBlockType;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint) mapSize || id.y >= (uint) mapSize)
        return;
    
    int x = (int) id.x;
    int z = (int) id.y;
    
    // Get normalized height (0-1)
    int borderedIndex = (z + borderSize) * mapSizeWithBorder + (x + borderSize);
    float normalizedHeight = heightMap[borderedIndex];
    
    // Calculate slope
    float slope = CalculateSlope(x, z);
    
    // Get blend noise
    float noise = GetBlendNoise(x, z);
    
    // Determine best block type using dynamic configuration
    int blockType = DetermineBlockType(normalizedHeight, slope, noise);
    
    // Store result
    int outputIndex = z * mapSize + x;
    blockData[outputIndex] = (uint) blockType;
}