#pragma kernel CSMain

#include "FastNoise.hlsl"

// Input
StructuredBuffer<float> heightMap;

// Terrain type configuration (matches C# TerrainRule)
struct TerrainRule
{
    int terrainType;
    float minHeight;
    float maxHeight;
    float heightBlendAmount;
    float minSlope;
    float maxSlope;
    float slopeBlendAmount;
    int priority;
    float strength;
    int useNoiseVariation;
    float noiseInfluence;
    float padding; // Alignment
};

StructuredBuffer<TerrainRule> terrainRules;

// Output
RWStructuredBuffer<uint> terrainData;

// Parameters
int mapSize;
int mapSizeWithBorder;
int borderSize;
float elevationScale;
float cellSize;
int numTerrainRules;

int seed;
float blendNoiseScale;

// Get height at position with bounds checking
float GetHeight(int x, int z)
{
    x = clamp(x, 0, mapSize - 1);
    z = clamp(z, 0, mapSize - 1);
    
    int borderedIndex = (z + borderSize) * mapSizeWithBorder + (x + borderSize);
    return heightMap[borderedIndex] * elevationScale;
}

// Calculate slope at a position
float CalculateSlope(int x, int z)
{
    float heightC = GetHeight(x, z);
    float heightL = GetHeight(x - 1, z);
    float heightR = GetHeight(x + 1, z);
    float heightD = GetHeight(x, z - 1);
    float heightU = GetHeight(x, z + 1);
    
    float dx = (heightR - heightL) / (2.0 * cellSize);
    float dz = (heightU - heightD) / (2.0 * cellSize);
    
    float slopeMagnitude = sqrt(dx * dx + dz * dz);
    return slopeMagnitude;
}

// Generate blend noise for smooth transitions
float GetBlendNoise(int x, int z)
{
    fnl_state state = fnlCreateState(seed);
    state.noise_type = FNL_NOISE_OPENSIMPLEX2;
    state.frequency = blendNoiseScale;
    
    return fnlGetNoise2D(state, x, z);
}

// Smooth step function for blending
float SmoothStep(float edge0, float edge1, float x)
{
    float t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);
}

// Calculate fitness score for a terrain type at given height and slope
float CalculateTerrainFitness(TerrainRule rule, float normalizedHeight, float slope, float noise)
{
    // Apply noise variation
    float heightNoise = (rule.useNoiseVariation != 0) ? noise * rule.noiseInfluence * rule.heightBlendAmount : 0.0;
    float slopeNoise = (rule.useNoiseVariation != 0) ? noise * rule.noiseInfluence * rule.slopeBlendAmount * 0.5 : 0.0;
    
    float adjustedHeight = normalizedHeight + heightNoise;
    float adjustedSlope = slope + slopeNoise;
    
    // Height fitness
    float heightFitness = 0.0;
    
    if (adjustedHeight >= rule.minHeight && adjustedHeight <= rule.maxHeight)
    {
        // Apply blend at edges
        if (adjustedHeight < rule.minHeight + rule.heightBlendAmount)
        {
            heightFitness = SmoothStep(rule.minHeight, rule.minHeight + rule.heightBlendAmount, adjustedHeight);
        }
        else if (adjustedHeight > rule.maxHeight - rule.heightBlendAmount)
        {
            heightFitness = 1.0 - SmoothStep(rule.maxHeight - rule.heightBlendAmount, rule.maxHeight, adjustedHeight);
        }
        else
        {
            heightFitness = 1.0;
        }
    }
    
    // Slope fitness
    float slopeFitness = 0.0;
    
    if (adjustedSlope >= rule.minSlope && adjustedSlope <= rule.maxSlope)
    {
        if (adjustedSlope < rule.minSlope + rule.slopeBlendAmount)
        {
            slopeFitness = SmoothStep(rule.minSlope, rule.minSlope + rule.slopeBlendAmount, adjustedSlope);
        }
        else if (adjustedSlope > rule.maxSlope - rule.slopeBlendAmount)
        {
            slopeFitness = 1.0 - SmoothStep(rule.maxSlope - rule.slopeBlendAmount, rule.maxSlope, adjustedSlope);
        }
        else
        {
            slopeFitness = 1.0;
        }
    }
    
    // Combine fitness
    float fitness = heightFitness * slopeFitness * rule.strength;
    
    return fitness;
}

// Determine best terrain type based on all rules
int DetermineTerrainType(float normalizedHeight, float slope, float noise)
{
    int bestTerrainType = 2; // Default to first type
    float bestScore = -1.0;
    int bestPriority = -1;
    
    // Evaluate each terrain rule
    for (int i = 0; i < numTerrainRules; i++)
    {
        TerrainRule rule = terrainRules[i];
        
        float fitness = CalculateTerrainFitness(rule, normalizedHeight, slope, noise);
        
        // Higher priority wins, or higher fitness if same priority
        bool isBetter = false;
        
        if (rule.priority > bestPriority)
        {
            isBetter = true;
        }
        else if (rule.priority == bestPriority && fitness > bestScore)
        {
            isBetter = true;
        }
        
        if (isBetter && fitness > 0.01)
        {
            bestTerrainType = rule.terrainType;
            bestScore = fitness;
            bestPriority = rule.priority;
        }
    }
    
    return bestTerrainType;
}

[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= (uint) mapSize || id.y >= (uint) mapSize)
        return;
    
    int x = (int) id.x;
    int z = (int) id.y;
    
    // Get normalized height (0-1)
    int borderedIndex = (z + borderSize) * mapSizeWithBorder + (x + borderSize);
    float normalizedHeight = heightMap[borderedIndex];
    
    // Calculate slope
    float slope = CalculateSlope(x, z);
    
    // Get blend noise
    float noise = GetBlendNoise(x, z);
    
    // Determine best terrain type using dynamic rules
    int terrainType = DetermineTerrainType(normalizedHeight, slope, noise);
    
    // Store result
    int outputIndex = z * mapSize + x;
    terrainData[outputIndex] = (uint) terrainType;
}